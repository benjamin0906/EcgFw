/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "GPIO.h"
#include "BasicTIM.h"
#include "Utilities.h"
#include "Hal.h"
#include "SysTick_red.h"
#include "usb_device.h"
#include "adasMngr.h"
#include "DMA.h"
#include "SPI.h"
#include "Filters/Filters_Task.h"
#include "Filters/Filters_Proc.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

static uint32 adasData[5];
static uint8 newAdasData;

void TestGpioSet(void)
{
    GPIO_Set(PortA_15, Set);
}

void TestGpioClear(void)
{
    GPIO_Set(PortA_15, Clear);
}

void BundleAdasTriggers(void)
{
    static uint8 BaselineDivider = 0;
    if(adasMngr_GetReadData(&adasData[0]) != 0)
    {
        newAdasData = 1;
    }
    adasMngr_TriggerRead();
    BaselineDivider++;
    if(BaselineDivider == 20)
    {
        IFilters_TriggerNewProcess();
        IFilters_NewValue(0, adasData[0]);
        BaselineDivider = 0;
    }
}

int main(void)
{
    halInit();
    uint8 adas = 0;
    uint32 data[16];
    uint8 dataSize = 0;

    uint32 outBuffer[16];
    uint8 outSize = 0;

    /* Loop forever */
	for(;;)
	{
        TestGpioSet();
	    adasMngr_Loop();
        TestGpioClear();
	    Filters_Runnable();
	    if(newAdasData != 0)
        {
	        dataSize &= 15;
	        data[dataSize++] = adasData[0] - IFilters_GetOutput(0);
            newAdasData = 0;
        }

	    if(CDC_IsTxBusy() != USBD_BUSY)
	    {
	        if((dataSize >= 10))
	        {
	            memcpy_reverse_32bit(data, outBuffer, dataSize);
                outSize = dataSize;
                if(USB_Transmit(outBuffer, 4*outSize) == USBD_OK)
                {
                    dataSize = 0;
                }
	        }
	    }//*/

        if(adas == 0)
        {
            if(adasMngr_SetState(AdasMngrState_Testing) == TransitionDone) adas = 1;
        }
	}
}
